from pathlib import Path

from metagraph_workflows.common import AnnotationLabelsSource, AnnotationFormats
from metagraph_workflows.resource_management import TransformRdStage0Resources, TransformRdStage1Resources, TransformRdStage2Resources, ResourceConfig

include: "common.smk"

wdir=Path(config['output_directory'])

graph=config['base_name']
build_primary=take_value_or_default('build_primary_graph', False)

annotation_formats = config['annotation_formats'] if isinstance(config['annotation_formats'], list) else [config['annotation_formats']]

# validate values
for af in annotation_formats:
    AnnotationFormats(af)
    # TODO: make a nicer error

annotation_labels_opt = AnnotationLabelsSource(config['annotation_labels_source']).to_annotation_cmd_option()

exec_cmd=config['exec_cmd']

max_threads=take_value_or_default('max_threads', workflow.cores)

# TODO
max_memory_mb=take_value_or_default('max_memory_mb', 4000)

verbose = config['verbose'] if 'verbose' in config else False
verbose_opt=' -v ' if verbose else ''

write_logs = take_value_or_default('write_logs', False)

log_dir=wdir/'logs'
if write_logs:
    log_dir.mkdir(exist_ok=True, parents=True)


DONE="DONE"

## Paths
graph_path=wdir/f'{graph}.dbg'
annotation_cols_path=wdir/'columns'
annotation_path_done=annotation_cols_path/DONE

columns_file=wdir/'columns.txt'

seqs_file_list_path=get_seqs_file_list_path()

localrules: generate_column_list

rule all:
     input:
        graph_path,
        [wdir/f'{graph}.{anno_type}.annodbg' for anno_type in annotation_formats]


include: 'build.smk'

rule_name="annotate"
rule annotate:
    input:
        seqs=seqs_file_list_path,
        dbg_graph=graph_path,
    output:
        done=touch(annotation_path_done),
        column_anno_files=generate_col_paths(seqs_file_list_path)
    threads: max_threads
    resources:
        mem_mb=ResourceConfig(rule_name).get_mem(config),
    params:
        log_writing=get_log_opt(rule_name),
    shell:
        """
        OUT_DIR=$(dirname {output.done})
        mkdir -p $OUT_DIR
        cat {input.seqs} | {exec_cmd} annotate \
          {verbose_opt} \
          --parallel {threads} \
          -i {input.dbg_graph} \
          {annotation_labels_opt} \
          --anno-type column \
          --separately \
          -o $OUT_DIR 2>&1 {params.log_writing}
        """

rule_name="generate_column_list"
rule generate_column_list:
    input: rules.annotate.output.column_anno_files
    output: columns_file
    run:
        with open(output[0], 'w') as f:
            f.write('\n'.join([str(l) for l in input]))


max_path_length=None

rule_name="generate_brwt_linkage"
rule generate_brwt_linkage:
    input:
        columns_file=columns_file,
    output:
        linkage=wdir/f"{graph}.linkage.txt"
    threads: max_threads
    resources:
        mem_mb=ResourceConfig(rule_name).get_mem(config),
    params:
        log_writing=get_log_opt(rule_name),
    shell:
        """        
        cat {input.columns_file} | {exec_cmd} transform_anno {verbose_opt} \
            --anno-type brwt \
            --linkage \
            --greedy \
            --subsample 10000000 \
            --parallel {threads} \
            -o {output.linkage} 2>&1 {params.log_writing}
        """

ruleorder: relax_brwt > transform_annotation # more specific rule has priority

rule_name="transform_annotation"
rule transform_annotation:
    input:
        columns_file=columns_file,
    output:
        annotations=wdir/f'{graph}.{{anno_type}}.annodbg',
    threads: max_threads
    resources:
        mem_mb=ResourceConfig(rule_name).get_mem(config),
    params:
        log_writing=get_log_opt("annotate_{anno_type}")
    shell:
        """        
        cat {input.columns_file} | {exec_cmd} transform_anno {verbose_opt} \
            --anno-type {wildcards.anno_type} \
            --parallel {threads} \
            -o {output.annotations} 2>&1 {params.log_writing}
        """


rule_name="annotate_brwt"
rule annotate_brwt:
    input:
        linkage=wdir/f"{graph}.linkage.txt",
        columns_file=columns_file,
    output:
        annotations=wdir/f'{graph}.brwt.annodbg',
    threads: max_threads
    resources:
        mem_mb=ResourceConfig(rule_name).get_mem(config),
    params:
        log_writing=get_log_opt(rule_name)
    shell:
        """        
        cat {input.columns_file} | {exec_cmd} transform_anno {verbose_opt} \
            --anno-type brwt \
            --parallel-nodes 10 \
            --greedy \
            --parallel {threads} \
            -o {output.annotations} 2>&1 {params.log_writing}
        """


rule_name="relax_brwt"
rule relax_brwt:
    input:
        brwt_annots=wdir/f'{graph}.{{brwt_fmt}}.annodbg',
    output:
        annotations=wdir/f'{graph}.relax.{{brwt_fmt}}.annodbg',
    threads: max_threads
    resources:
        mem_mb=ResourceConfig(rule_name).get_mem(config),
    params:
        log_writing=get_log_opt(rule_name),
    shell:
        """        
        {exec_cmd} relax_brwt \
            -o {output.annotations} \
            {verbose_opt} \
            --relax-arity 15 \
            --parallel {threads} \
            {input.brwt_annots} 2>&1 {params.log_writing}
        """

transform_row_diff_overhead_mb=2000

rd_cols_dir = wdir/f'{graph}_rd_cols'

from metagraph_workflows.resource_management import TransformRdStage0Resources

rule_name="transform_rd_stage0"
rule transform_rd_stage0:
    input:
        dbg_graph=graph_path,
        columns_file=columns_file,
    output:
        columns_rd_row_count=rd_cols_dir/'vector.row_count'
    threads: max_threads
    resources:
        mem_mb=TransformRdStage0Resources().get_mem(config)
    params:
        mem_cap=TransformRdStage0Resources().get_mem_cap(config),
        log_writing=get_log_opt(rule_name),
        tempdir_opt=cfg_utils.temp_dir_config(config),
    shell:
        """
        COLS_DIR=$(dirname {output.columns_rd_row_count})
        mkdir -p $COLS_DIR
        
        cat {input.columns_file} | {exec_cmd} transform_anno {verbose_opt} \
            --anno-type row_diff \
            --row-diff-stage 0 \
            -i {input.dbg_graph} \
            --parallel {threads} \
            --mem-cap-gb {params.mem_cap} \
            -o {output.columns_rd_row_count} {params.tempdir_opt} 2>&1 {params.log_writing}
        """

rule_name="transform_rd_stage1"
rule transform_rd_stage1:
    input:
        dbg_graph=graph_path,
        columns_file=columns_file,
        columns_rd_row_count=rd_cols_dir/'vector.row_count'
    output:
        pred=wdir / f'{graph}.dbg.pred',
        pred_boundary=wdir / f'{graph}.dbg.pred_boundary',
        rd_succ=wdir / f'{graph}.dbg.rd_succ',
        succ=wdir / f'{graph}.dbg.succ',
        succ_boundary=wdir / f'{graph}.dbg.succ_boundary',
        cols_rd_vectors=rd_cols_dir / 'vectors.row_reduction'
    threads: max_threads
    resources:
        mem_mb=TransformRdStage1Resources().get_mem(config)
    params:
        mem_cap=TransformRdStage1Resources().get_mem_cap(config),
        log_writing=get_log_opt(rule_name),
        tempdir_opt=cfg_utils.temp_dir_config(config),
    shell:
        """
        cat {input.columns_file} | {exec_cmd} transform_anno {verbose_opt} \
            --anno-type row_diff \
            --row-diff-stage 1 \
            -i {input.dbg_graph} \
            --parallel {threads} \
            --mem-cap-gb {params.mem_cap} \
            -o {output.cols_rd_vectors} {params.tempdir_opt} 2>&1 {params.log_writing}
        """


rule_name="transform_rd_stage2"
rule transform_rd_stage2:
    input:
        dbg_graph=graph_path,
        columns_file=columns_file,
        cols_rd_vectors=rd_cols_dir / 'vectors.row_reduction'
    output:
        anchors=wdir/f'{graph}.dbg.anchors',
        rd_cols_done=touch(rd_cols_dir/DONE)
    threads: max_threads
    resources:
        mem_mb=TransformRdStage2Resources().get_mem(config),
    params:
        mem_cap=TransformRdStage2Resources().get_mem_cap(config),
        log_writing=get_log_opt(rule_name),
        tempdir_opt=cfg_utils.temp_dir_config(config),
    shell:
        """
        cat {input.columns_file} | {exec_cmd} transform_anno {verbose_opt} \
            --anno-type row_diff \
            --row-diff-stage 2 \
            -i {input.dbg_graph} \
            --parallel {threads} \
            --mem-cap-gb {params.mem_cap} \
            -o {output.rd_cols_done} {params.tempdir_opt} 2>&1 {params.log_writing}
        """


rule_name="annotate_row_diff_brwt"
rule annotate_row_diff_brwt:
    input:
        anchors=rules.transform_rd_stage2.output.anchors,
        rd_cols_done=rules.transform_rd_stage2.output.rd_cols_done,
        dbg_graph=graph_path
    output:
        annotations=wdir/f'{graph}.row_diff_brwt.annodbg',
        linkage=wdir / f'{graph}.row_diff_brwt.annodbg.linkage',
    threads: max_threads
    resources:
        mem_mb=ResourceConfig(rule_name).get_mem(config),
    params:
        log_writing=get_log_opt(rule_name),
        tempdir_opt=cfg_utils.temp_dir_config(config),
    shell:
        """
        echo $(find $(dirname {input.rd_cols_done}) -name \*.annodbg)
        find $(dirname {input.rd_cols_done}) -name \*.annodbg | {exec_cmd} transform_anno {verbose_opt} \
            --anno-type row_diff_brwt \
            --greedy \
            --fast \
            --parallel-nodes 5 \
            --parallel {threads} \
            -i {input.dbg_graph} \
            -o {output.annotations} {params.tempdir_opt} 2>&1 {params.log_writing}
        """


rule_name="relax_row_diff_brwt"
rule relax_row_diff_brwt:
    input:
        brwt_annots=rules.annotate_row_diff_brwt.output.annotations,
    output:
        annotations_relaxed=wdir/f'{graph}.relax.row_diff_brwt.annodbg',
    threads: max_threads
    resources:
        mem_mb=ResourceConfig(rule_name).get_mem(config),
    params:
        log_writing=get_log_opt(rule_name),
    shell:
        """        
        {exec_cmd} relax_brwt \
            -o {output.annotations_relaxed} \
            {verbose_opt} \
            --relax-arity 15 \
            --parallel {threads} \
            {input.brwt_annots} 2>&1 {params.log_writing}
        """
