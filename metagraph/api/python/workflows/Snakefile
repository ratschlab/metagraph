import itertools
import os
from pathlib import Path

from psutil import virtual_memory

from metagraph.cli.common import AnnotationLabelsSource, AnnotationFormats
from metagraph.cli import utils
from metagraph.cli.constants import SEQS_FILE_LIST_PATH, SEQS_DIR_PATH


def take_value_or_default(key, default):
    return config[key] if (key in config.keys() and config[key]) else default

wdir=Path(config['output_directory'])

graph=config['base_name']
build_primary=take_value_or_default('build_primary_graph', False)

annotation_formats = config['annotation_formats'] if isinstance(config['annotation_formats'], list) else [config['annotation_formats']]

# validate values
for af in annotation_formats:
    AnnotationFormats(af)
    # TODO: make a nicer error

annotation_labels_opt = AnnotationLabelsSource(config['annotation_labels_source']).to_annotation_cmd_option()

exec_cmd=config['exec_cmd']

max_threads=take_value_or_default('max_threads', workflow.cores)

# if not set, use half of the installed memory. Arbitary heuristic. Not using
# available memory, as otherwise behaviour between runs could change significantly
# for no apparent reason
max_memory_mb=take_value_or_default('max_memory_mb', virtual_memory().total/1024**2/2)

verbose = config['verbose'] if 'verbose' in config else False
verbose_opt=' -v ' if verbose else ''

write_logs = take_value_or_default('write_logs', False)

log_dir=wdir/'logs'
if write_logs:
    log_dir.mkdir(exist_ok=True, parents=True)

def get_log_opt(rule):
    return f" | tee {log_dir}/{graph}_{rule}.log" if write_logs else ''

DONE="DONE"

## Paths
graph_path=wdir/f'{graph}.dbg'
annotation_cols_path=wdir/'columns'
annotation_path_done=annotation_cols_path/DONE

columns_file=wdir/'columns.txt'

seqs_file_list_path=config.get(SEQS_FILE_LIST_PATH, None)

if not seqs_file_list_path:
    seqs_file_list_path = wdir/'sequence_file_list_path.txt'
    seqs_dir_path = config.get(SEQS_DIR_PATH, None)

    if not seqs_dir_path:
        raise ValueError(f"Neither {SEQS_FILE_LIST_PATH} nor {SEQS_DIR_PATH} parameter are set. Need either to proceed")

    utils.create_transcript_path_list(seqs_dir_path, seqs_file_list_path)


localrules: generate_column_list

rule all:
     input:
        graph_path,
        [wdir/f'{graph}.{anno_type}.annodbg' for anno_type in annotation_formats]


include: 'build.smk'

def generate_col_paths(seq_file):
    with open(seq_file) as f:
        column_names = [f"{f.strip().split('/')[-1]}" for f in f.readlines()]

        duplicate_col_names = [grp_key for (grp_key, names_lst) in itertools.groupby(sorted(column_names)) if len(list(names_lst)) > 1]
        assert not duplicate_col_names, f"Found duplicate filenames: { ', '.join(duplicate_col_names)}"

        return [ annotation_cols_path/f"{c}.column.annodbg" for c in column_names]


rule annotate:
    input:
        seqs=seqs_file_list_path,
        dbg_graph=graph_path,
    output:
        done=touch(annotation_path_done),
        column_anno_files=generate_col_paths(seqs_file_list_path)
    threads: max_threads
    params:
        log_writing=get_log_opt("annotate"),
    shell:
        """
        OUT_DIR=$(dirname {output.done})
        mkdir -p $OUT_DIR
        cat {input.seqs} | {exec_cmd} annotate \
          {verbose_opt} \
          --parallel {threads} \
          -i {input.dbg_graph} \
          {annotation_labels_opt} \
          --anno-type column \
          --separately \
          -o $OUT_DIR 2>&1 {params.log_writing}
        """

rule generate_column_list:
    input: rules.annotate.output.column_anno_files
    output: columns_file
    run:
        with open(output[0], 'w') as f:
            f.write('\n'.join([str(l) for l in input]))


max_path_length=None

rule generate_brwt_linkage:
    input:
        columns_file=columns_file,
    output:
        linkage=wdir/f"{graph}.linkage.txt"
    threads: max_threads
    params:
        log_writing=get_log_opt("brwt_linkage"),
    shell:
        """        
        cat {input.columns_file} | {exec_cmd} transform_anno {verbose_opt} \
            --anno-type brwt \
            --linkage \
            --greedy \
            --subsample 10000000 \
            --parallel {threads} \
            -o {output.linkage} 2>&1 {params.log_writing}
        """

ruleorder: relax_brwt > transform_annotation # more specific rule has priority

rule transform_annotation:
    input:
        columns_file=columns_file,
    output:
        annotations=wdir/f'{graph}.{{anno_type}}.annodbg',
    threads: max_threads
    params:
        log_writing=get_log_opt("annotate_{anno_type}")
    shell:
        """        
        cat {input.columns_file} | {exec_cmd} transform_anno {verbose_opt} \
            --anno-type {wildcards.anno_type} \
            --parallel {threads} \
            -o {output.annotations} 2>&1 {params.log_writing}
        """


rule annotate_brwt:
    input:
        linkage=wdir/f"{graph}.linkage.txt",
        columns_file=columns_file,
    output:
        annotations=wdir/f'{graph}.brwt.annodbg',
    threads: max_threads
    params:
        log_writing=get_log_opt("annotate_brwt")
    shell:
        """        
        cat {input.columns_file} | {exec_cmd} transform_anno {verbose_opt} \
            --anno-type brwt \
            --parallel-nodes 10 \
            --greedy \
            --parallel {threads} \
            -o {output.annotations} 2>&1 {params.log_writing}
        """


rule relax_brwt:
    input:
        brwt_annots=wdir/f'{graph}.{{brwt_fmt}}.annodbg',
    output:
        annotations=wdir/f'{graph}.relax.{{brwt_fmt}}.annodbg',
    threads: max_threads
    params:
        log_writing=get_log_opt("relax_brwt"),
    shell:
        """        
        {exec_cmd} relax_brwt \
            -o {output.annotations} \
            {verbose_opt} \
            --relax-arity 15 \
            --parallel {threads} \
            {input.brwt_annots} 2>&1 {params.log_writing}
        """


def columns_size_mb(columns_file):
    with open(columns_file) as f:
        col_file_size_bytes = sum(os.stat(l.strip()).st_size for l in f)
        return col_file_size_bytes/1024**2


transform_row_diff_overhead_mb=2000

rd_cols_dir = wdir/f'{graph}_rd_cols'

rule transform_row_diff_stage0:
    input:
        dbg_graph=graph_path,
        columns_file=columns_file,
    output:
        columns_rd_row_count=rd_cols_dir/'vector.row_count'
    threads: max_threads
    resources:
        mem_mb=lambda wildcards, input: int(min(transform_row_diff_overhead_mb + columns_size_mb(input.columns_file), max_memory_mb))
    params:
        mem_cap=lambda wildcards, resources: int((resources.mem_mb - transform_row_diff_overhead_mb)/1024.0) + 1,
        log_writing=get_log_opt("transform_row_diff_opt")
    shell:
        """
        COLS_DIR=$(dirname {output.columns_rd_row_count})
        mkdir -p $COLS_DIR
        
        cat {input.columns_file} | {exec_cmd} transform_anno {verbose_opt} \
            --anno-type row_diff \
            --row-diff-stage 0 \
            -i {input.dbg_graph} \
            --parallel {threads} \
            --mem-cap-gb {params.mem_cap} \
            -o {output.columns_rd_row_count} 2>&1 {params.log_writing}
        """

rule transform_row_diff_stage1:
    input:
        dbg_graph=graph_path,
        columns_file=columns_file,
        columns_rd_row_count=rd_cols_dir/'vector.row_count'
    output:
        pred=wdir / f'{graph}.dbg.pred',
        pred_boundary=wdir / f'{graph}.dbg.pred_boundary',
        rd_succ=wdir / f'{graph}.dbg.rd_succ',
        succ=wdir / f'{graph}.dbg.succ',
        succ_boundary=wdir / f'{graph}.dbg.succ_boundary',
        cols_rd_vectors=rd_cols_dir / 'vectors.row_reduction'
    threads: max_threads
    resources:
        mem_mb=lambda wildcards, input: int(min(transform_row_diff_overhead_mb + columns_size_mb(input.columns_file), max_memory_mb))
    params:
        mem_cap=lambda wildcards, resources: int((resources.mem_mb - transform_row_diff_overhead_mb)/1024.0) + 1,
        log_writing=get_log_opt("transform_row_diff_opt")
    shell:
        """
        cat {input.columns_file} | {exec_cmd} transform_anno {verbose_opt} \
            --anno-type row_diff \
            --row-diff-stage 1 \
            -i {input.dbg_graph} \
            --parallel {threads} \
            --mem-cap-gb {params.mem_cap} \
            -o {output.cols_rd_vectors} 2>&1 {params.log_writing}
        """

rule transform_row_diff_stage2:
    input:
        dbg_graph=graph_path,
        columns_file=columns_file,
        cols_rd_vectors=rd_cols_dir / 'vectors.row_reduction'
    output:
        anchors=wdir/f'{graph}.dbg.anchors',
        rd_cols_done=touch(rd_cols_dir/DONE)
    threads: max_threads
    resources:
        mem_mb=lambda wildcards, input: int(min(transform_row_diff_overhead_mb + columns_size_mb(input.columns_file), max_memory_mb))
    params:
        mem_cap=lambda wildcards, resources: int((resources.mem_mb - transform_row_diff_overhead_mb)/1024.0) + 1,
        log_writing=get_log_opt("transform_row_diff_opt")
    shell:
        """
        cat {input.columns_file} | {exec_cmd} transform_anno {verbose_opt} \
            --anno-type row_diff \
            --row-diff-stage 2 \
            -i {input.dbg_graph} \
            --parallel {threads} \
            --mem-cap-gb {params.mem_cap} \
            -o {output.rd_cols_done} 2>&1 {params.log_writing}
        """


rule annotate_row_diff_brwt:
    input:
        anchors=rules.transform_row_diff_stage2.output.anchors,
        rd_cols_done=rules.transform_row_diff_stage2.output.rd_cols_done,
        dbg_graph=graph_path
    output:
        annotations=wdir/f'{graph}.row_diff_brwt.annodbg',
        linkage=wdir / f'{graph}.row_diff_brwt.annodbg.linkage',
    threads: max_threads
    params:
        log_writing=get_log_opt("annotate_row_diff_brwt"),
    shell:
        """
        echo $(find $(dirname {input.rd_cols_done}) -name \*.annodbg)
        find $(dirname {input.rd_cols_done}) -name \*.annodbg | {exec_cmd} transform_anno {verbose_opt} \
            --anno-type row_diff_brwt \
            --greedy \
            --fast \
            --parallel-nodes 5 \
            --parallel {threads} \
            -i {input.dbg_graph} \
            -o {output.annotations} 2>&1 {params.log_writing}
        """


rule relax_row_diff_brwt:
    input:
        brwt_annots=rules.annotate_row_diff_brwt.output.annotations,
    output:
        annotations_relaxed=wdir/f'{graph}.relax.row_diff_brwt.annodbg',
    threads: max_threads
    params:
        log_writing=get_log_opt("relax_row_diff_brwt"),
    shell:
        """        
        {exec_cmd} relax_brwt \
            -o {output.annotations_relaxed} \
            {verbose_opt} \
            --relax-arity 15 \
            --parallel {threads} \
            {input.brwt_annots} 2>&1 {params.log_writing}
        """