#include <json/json.h>
#include <server_http.hpp>

#include "common/logger.hpp"
#include "common/unix_tools.hpp"
#include "common/utils/string_utils.hpp"
#include "common/utils/file_utils.hpp"
#include "graph/alignment/dbg_aligner.hpp"
#include "seq_io/sequence_io.hpp"
#include "config/config.hpp"
#include "load/load_graph.hpp"
#include "load/load_annotated_graph.hpp"
#include "query.hpp"
#include "align.hpp"
#include "server_utils.hpp"

using namespace mtg;
using mtg::common::logger;

using HttpServer = SimpleWeb::Server<SimpleWeb::HTTP>;

const std::string SEQ_DESCRIPTION_JSON_FIELD = "seq_description";
const std::string SCORE_JSON_FIELD = "score";
const std::string SEQUENCE_JSON_FIELD = "sequence";

// convert values into proper types, i.e. 'nan' -> null, strings representing numbers -> numbers
Json::Value adjust_for_types(const std::string &v) {
    if (v == "nan")
        return Json::nullValue;

    try {
        return Json::Value(std::stof(v));
    } catch(...) {};

    return Json::Value(v);
}

std::string convert_query_response_to_json(const std::string &ret_str) {
    // TODO: we are parsing back the string generated by the 'query' code, which is ugly.
    // we should have an intermediate representation which can be converted to a string (when
    // query is invoked from the command line) or to a json (string) when invoked by the server.
    std::vector<std::string> queries = utils::split_string(ret_str, "\n");

    std::vector<std::pair<long long, Json::Value>> query_results;
    query_results.reserve(query_results.size());

    for (auto qit = queries.begin(); qit != queries.end(); ++qit) {
        std::vector<std::string> parts = utils::split_string(*qit, "\t", false);

        if (parts.size() <= 2)
            continue; // no sequences found

        Json::Value res_obj;
        std::vector<std::string> query_desc_parts = utils::split_string(parts[1], ":");

        res_obj[SEQ_DESCRIPTION_JSON_FIELD] = "";
        if (!query_desc_parts.empty())
            res_obj[SEQ_DESCRIPTION_JSON_FIELD] = query_desc_parts[0];

        if (query_desc_parts.size() > 1) {
            // we aligned first, so extracting aligned sequence and score:

            res_obj[SEQUENCE_JSON_FIELD] = query_desc_parts[1];
            res_obj[SCORE_JSON_FIELD] = (int)atoi(query_desc_parts[2].c_str());
        }

        res_obj["results"] = Json::Value(Json::arrayValue);

        for (size_t i = 2; i < parts.size(); ++i) {
            Json::Value sampleEntry;

            std::vector<std::string> entries = utils::split_string(parts[i], ":");

            std::vector<std::string> labels
                = utils::split_string(entries[0].substr(1, entries[0].size() - 2), ";");

            sampleEntry["sample"] = labels[0];

            Json::Value properties = Json::objectValue;

            for (auto lit = ++labels.begin(); lit != labels.end(); ++lit) {
                std::vector<std::string> key_value = utils::split_string(*lit, "=");
                properties[key_value[0]] = adjust_for_types(key_value[1]);
            }

            if (properties.size() > 0) {
                sampleEntry["properties"] = properties;
            }
            sampleEntry["kmer_count"] = (int)atoi(entries[1].c_str());

            res_obj["results"].append(sampleEntry);
        }

        query_results.emplace_back(atoll(parts[0].c_str()), std::move(res_obj));
    }

    std::sort(query_results.begin(), query_results.end(), utils::LessFirst());

    Json::Value root = Json::Value(Json::arrayValue);
    // output by query id
    for (const auto &[id, res_obj] : query_results) {
        root.append(res_obj);
    }

    Json::StreamWriterBuilder builder;
    return Json::writeString(builder, root);
}


std::string process_search_request(const std::string &received_message,
                                   const AnnotatedDBG &anno_graph,
                                   const Config &config_orig,
                                   const IDBGAligner &aligner) {
    Json::Value json = parse_json_string(received_message);

    const auto &fasta = json["FASTA"];
    if (fasta.isNull())
        throw std::domain_error("No input sequences received from client");

    Config config(config_orig);

    // discovery_fraction a proxy of 1 - %similarity
    config.discovery_fraction
            = json.get("discovery_fraction", config.discovery_fraction).asDouble();

    if (config.discovery_fraction < 0.0 || config.discovery_fraction > 1.0) {
        throw std::domain_error(
                "Discovery fraction should be within [0, 1.0]. Instead got "
                + std::to_string(config.discovery_fraction));
    }

    config.count_labels = true;
    config.num_top_labels = json.get("num_labels", config.num_top_labels).asInt();
    config.fast = json.get("fast", config.fast).asBool();

    bool do_alignment = json.get("align", false).asBool();

    std::ostringstream oss;
    std::mutex oss_mutex;

    // writing to temporary file in order to reuse query code. This is not optimal and
    // may turn out to be an issue in production. However, adapting FastaParser to
    // work on strings seems non-trivial. An alternative would be to use
    // read_fasta_from_string for non fast queries.
    utils::TempFile tf(config.tmp_dir);
    tf.ofstream() << fasta.asString();
    tf.ofstream().close();

    // dummy pool doing everything in the caller thread
    ThreadPool dummy_pool(0);
    QueryExecutor engine(config, anno_graph, do_alignment ? &aligner : NULL,
                         dummy_pool);

    engine.query_fasta(tf.name(),
        [&](const std::string &res) {
            std::lock_guard<std::mutex> lock(oss_mutex);
            oss << res;
        }
    );

    return convert_query_response_to_json(oss.str());
}

std::string process_align_request(const std::string &received_message,
                                  const IDBGAligner &aligner) {
    Json::Value json = parse_json_string(received_message);

    const auto &fasta = json["FASTA"];

    Json::Value root = Json::Value(Json::arrayValue);

    seq_io::read_fasta_from_string(fasta.asString(),
                                   [&](seq_io::kseq_t *read_stream) {
        const auto paths = aligner.align(read_stream->seq.s);

        Json::Value align_entry;
        align_entry[SEQ_DESCRIPTION_JSON_FIELD] = read_stream->name.s;

        // not supporting reverse complement yet
        if (!paths.empty()) {
            auto path = paths.front();

            align_entry[SCORE_JSON_FIELD] = path.get_score();
            align_entry[SEQUENCE_JSON_FIELD] = path.get_sequence();
        } else {
            align_entry[SEQUENCE_JSON_FIELD] = "";
        }

        root.append(align_entry);
    });

    Json::StreamWriterBuilder builder;
    return Json::writeString(builder, root);
}

std::string process_column_label_request(const AnnotatedDBG &anno_graph) {
    auto labels = anno_graph.get_annotation().get_all_labels();

    Json::Value root = Json::Value(Json::arrayValue);

    for (const std::string &label : labels) {
        Json::Value entry = label;
        root.append(entry);
    }

    Json::StreamWriterBuilder builder;
    return Json::writeString(builder, root);
}


int run_server(Config *config) {
    assert(config);

    assert(config->infbase_annotators.size() == 1);

    logger->info("[Server] Loading graph...");

    auto graph = load_critical_dbg(config->infbase);
    auto anno_graph = initialize_annotated_dbg(graph, *config);

    logger->info("[Server] Graph loaded. Current mem usage: {} MiB", get_curr_RSS() >> 20);

    std::unique_ptr<IDBGAligner> aligner;
    aligner.reset(build_aligner(*graph, *config).release());

    const size_t num_threads = std::max(1u, get_num_threads());

    HttpServer server;
    server.config.thread_pool_size = num_threads;
    if (config->host_address != "") {
        logger->info("[Server] Will listen on interface {}", config->host_address);
        server.config.address = config->host_address;
    }

    server.config.port = config->port;

    config->num_top_labels = 10000;
    config->fast = true;

    server.resource["^/search"]["POST"] = [&](shared_ptr<HttpServer::Response> response,
                                              shared_ptr<HttpServer::Request> request) {
        process_request(response, request, [&](const std::string &content) {
            return process_search_request(content, *anno_graph, *config, *aligner);
        });
    };

    server.resource["^/align"]["POST"] = [&](shared_ptr<HttpServer::Response> response,
                                             shared_ptr<HttpServer::Request> request) {
        process_request(response, request, [&](const std::string &content) {
            return process_align_request(content, *aligner);
        });
    };

    server.resource["^/column_labels"]["GET"] = [&](shared_ptr<HttpServer::Response> response,
                                                    shared_ptr<HttpServer::Request> request) {
        process_request(response, request, [&](const std::string &) {
            return process_column_label_request(*anno_graph);
        });
    };

    server.default_resource["GET"] = [](shared_ptr<HttpServer::Response> response,
                                        shared_ptr<HttpServer::Request> request) {
        logger->info("Not found " + request->path);
        response->write(SimpleWeb::StatusCode::client_error_not_found,
                        "Could not find path " + request->path);
    };
    server.default_resource["POST"] = server.default_resource["GET"];

    server.on_error = [](shared_ptr<HttpServer::Request> /*request*/,
                         const SimpleWeb::error_code &ec) {
        // Handle errors here, ignoring a few trivial ones.
        if (ec.value() != asio::stream_errc::eof
                && ec.value() != asio::error::operation_aborted) {
            logger->info("[Server] Got error {} {} {}",
                         ec.message(), ec.category().name(), ec.value());
        }
    };

    std::promise<unsigned short> server_port;
    std::thread server_thread([&server, &server_port]() {
        server.start([&server_port](unsigned short port) { server_port.set_value(port); });
    });

    logger->info("[Server] Initializing a HTTP server with {} threads"
                 ", listening on port {}",
                 num_threads, server_port.get_future().get());

    server_thread.join();

    return 0;
}
