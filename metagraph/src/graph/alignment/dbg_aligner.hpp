#ifndef __DBG_ALIGNER_HPP__
#define __DBG_ALIGNER_HPP__

#include <cassert>
#include <functional>

#include "aligner_helper.hpp"
#include "aligner_methods.hpp"
#include "graph/representation/base/sequence_graph.hpp"


namespace mtg {
namespace graph {
namespace align {

class IDBGAligner {
  public:
    typedef DeBruijnGraph::node_index node_index;
    typedef Alignment<node_index> DBGAlignment;
    typedef QueryAlignment<node_index> DBGQueryAlignment;
    typedef typename DBGAlignment::score_t score_t;

    typedef std::function<void(std::string_view /* header */,
                               std::string_view /* seq */,
                               bool /* orientation of seq */)> QueryCallback;
    typedef std::function<void(const QueryCallback&)> QueryGenerator;
    typedef std::function<void(std::string_view /* header */,
                               DBGQueryAlignment&& /* alignments */)> AlignmentCallback;

    virtual ~IDBGAligner() {}

    virtual void align_batch(const QueryGenerator &generate_query,
                             const AlignmentCallback &callback) const = 0;
    DBGQueryAlignment align(std::string_view query,
                            bool is_reverse_complement = false) const;
};

template <class AlignmentCompare = std::less<IDBGAligner::DBGAlignment>>
class ISeedAndExtendAligner : public IDBGAligner {
  public:
    typedef IDBGAligner::node_index node_index;
    typedef IDBGAligner::DBGAlignment DBGAlignment;
    typedef IDBGAligner::DBGQueryAlignment DBGQueryAlignment;
    typedef IDBGAligner::score_t score_t;

    ISeedAndExtendAligner(const DeBruijnGraph &graph, const DBGAlignerConfig &config)
          : graph_(graph), config_(config) {
        assert(config_.num_alternative_paths);
        if (!config_.check_config_scores()) {
            throw std::runtime_error("Error: sum of min_cell_score and lowest penalty too low.");
        }
    }

    virtual ~ISeedAndExtendAligner() {}

    const DeBruijnGraph& get_graph() const { return graph_; }
    const DBGAlignerConfig& get_config() const { return config_; }

  protected:
    typedef std::function<void(DBGAlignment&&)> LocalAlignmentCallback;
    typedef std::function<score_t(const DBGAlignment&)> MinScoreComputer;
    typedef const std::function<void(const LocalAlignmentCallback&,
                                     const MinScoreComputer&)> AlignmentGenerator;

    // Generate seeds, then extend them
    void align_core(std::string_view query,
                    const ISeeder<node_index> &seeder,
                    IExtender<node_index>&& extender,
                    const LocalAlignmentCallback &callback,
                    const MinScoreComputer &get_min_path_score) const;

    // Align the query sequence in the given orientation (false is forward,
    // true is reverse complement)
    void align_one_direction(DBGQueryAlignment &paths,
                             bool orientation_to_align,
                             const ISeeder<node_index> &seeder,
                             IExtender<node_index>&& extender) const;

    // Align both the forward and reverse complement of the query sequence,
    // then report the best scoring alignment.
    void align_best_direction(DBGQueryAlignment &paths,
                              const ISeeder<node_index> &seeder,
                              const ISeeder<node_index> &seeder_rc,
                              IExtender<node_index>&& extender,
                              IExtender<node_index>&& extender_rc) const;

    // Align both forwards and backwards from a given seed. Procedure
    // 1. Given each seed, extend forward to produce an alignment A
    // 2. Reverse complement the alignment to get A', treated like a new seed
    // 3. Extend A' forwards
    // 4. Reverse complement A' to get the final alignment A''
    void align_both_directions(DBGQueryAlignment &paths,
                               const ISeeder<node_index> &forward_seeder,
                               IExtender<node_index>&& forward_extender) const;

    // Given the reverse complement of the query, the seeder for the forward
    // direction of the query, and an initial set of seeds for reverse_query,
    // generate a seeder and extender pair to extend in the reverse complement direction
    virtual std::pair<std::unique_ptr<ISeeder<node_index>>,
                      std::unique_ptr<IExtender<node_index>>>
    build_rev_comp_seeder_extender(std::string_view reverse_query,
                                   const ISeeder<node_index> &forward_seeder,
                                   std::vector<DBGAlignment>&& rev_comp_seeds) const = 0;

    // Given alignments generated by a generator, add them to a priority queue
    // and add the top ones to paths.
    virtual void
    align_aggregate(DBGQueryAlignment &paths,
                    const AlignmentGenerator &alignment_generator) const;

    const DeBruijnGraph &graph_;
    DBGAlignerConfig config_;
};

template <class Seeder = ExactSeeder<>,
          class Extender = DefaultColumnExtender<>,
          class AlignmentCompare = std::less<Alignment<>>>
class DBGAligner : public ISeedAndExtendAligner<AlignmentCompare> {
  public:
    typedef IDBGAligner::node_index node_index;
    typedef IDBGAligner::DBGAlignment DBGAlignment;
    typedef IDBGAligner::DBGQueryAlignment DBGQueryAlignment;
    typedef IDBGAligner::score_t score_t;
    typedef IDBGAligner::QueryGenerator QueryGenerator;
    typedef IDBGAligner::AlignmentCallback AlignmentCallback;

    DBGAligner(const DeBruijnGraph &graph, const DBGAlignerConfig &config)
          : ISeedAndExtendAligner<AlignmentCompare>(graph, config) {}

    virtual void align_batch(const QueryGenerator &generate_query,
                             const AlignmentCallback &callback) const override final;

  protected:
    inline Extender build_extender(std::string_view query) const {
        return { this->graph_, this->config_, query };
    }

    // Given the reverse complement of the query, the seeder for the forward
    // direction of the query, and an initial set of seeds for reverse_query,
    // generate a seeder and extender pair to extend in the reverse complement direction
    virtual std::pair<std::unique_ptr<ISeeder<node_index>>,
                      std::unique_ptr<IExtender<node_index>>>
    build_rev_comp_seeder_extender(std::string_view reverse_query,
                                   const ISeeder<node_index> &,
                                   std::vector<DBGAlignment>&& rev_comp_seeds) const override final {
        auto seeder_rc = std::make_unique<ManualSeeder<node_index>>(
            std::move(rev_comp_seeds)
        );

        return std::make_pair(std::move(seeder_rc),
                              std::make_unique<Extender>(build_extender(reverse_query)));
    }
};


template <class Seeder, class Extender, class AlignmentCompare>
inline void DBGAligner<Seeder, Extender, AlignmentCompare>
::align_batch(const QueryGenerator &generate_query,
              const AlignmentCallback &callback) const {
    generate_query([&](std::string_view header,
                       std::string_view query,
                       bool is_reverse_complement) {
        DBGQueryAlignment paths(query, is_reverse_complement);
        std::string_view this_query = paths.get_query(is_reverse_complement);
        assert(this_query == query);

        assert(this->config_.num_alternative_paths);
        Seeder seeder(this->graph_, this_query, // use this_query since paths stores a copy
                      is_reverse_complement, map_sequence_to_nodes(this->graph_, query),
                      this->config_);

        if (this->graph_.is_canonical_mode()) {
            assert(!is_reverse_complement);
            // From a given seed, align forwards, then reverse complement and
            // align backwards. The graph needs to be canonical to ensure that
            // all paths exist even when complementing.
            this->align_both_directions(paths, seeder, build_extender(this_query));
        } else if (this->config_.forward_and_reverse_complement) {
            assert(!is_reverse_complement);
            std::string_view reverse = paths.get_query(true);

            Seeder seeder_rc(this->graph_, reverse, !is_reverse_complement,
                             map_sequence_to_nodes(this->graph_, reverse), this->config_);

            this->align_best_direction(paths, seeder, seeder_rc,
                                       build_extender(this_query),
                                       build_extender(reverse));
        } else {
            this->align_one_direction(paths, is_reverse_complement, seeder,
                                      build_extender(this_query));
        }

        callback(header, std::move(paths));
    });
}

} // namespace align
} // namespace graph
} // namespace mtg

#endif // __DBG_ALIGNER_HPP__
